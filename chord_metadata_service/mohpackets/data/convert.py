import json
import os
from pathlib import Path


def convert_to_fixtures():
    """
    Converts the raw data generated by Mockaroo into Django fixtures
    by wrapping each object with the model name and fields.
    """

    # Path to the synthetic data folder
    script_dir = os.path.dirname(__file__)  # <-- absolute dir the script is in
    synthetic_folder_path = os.path.join(script_dir, "synthetic_data")
    fixtures_folder_path = os.path.join(script_dir, "fixtures")
    # create fixtures folder if it doesn't exist
    Path(fixtures_folder_path).mkdir(parents=True, exist_ok=True)

    # get all the json names in the directory data
    json_names = []
    for file in os.listdir(synthetic_folder_path):
        if file.endswith(".json"):
            json_names.append(file)

    # open each json file
    for file_name in json_names:
        print(f"Processing {file_name}...")
        obj_name = file_name.split(".")[0].lower()
        dj_fixtures = []
        with open(f"{synthetic_folder_path}/{file_name}") as f:
            data = json.load(f)

            for line in data:
                # create new json object
                dj_fixture = {"model": "mohpackets." + obj_name, "fields": line}
                dj_fixtures.append(dj_fixture)

        # write to new json file
        with open(f"{fixtures_folder_path}/{file_name}", "w") as f:
            json.dump(dj_fixtures, f, indent=4)


def set_foreign_keys():
    # Open the file
    with open(
        "chord_metadata_service/mohpackets/data/relationship_template.json", "r"
    ) as f:
        rules = json.load(f)

    name_dict = {
        "primary_diagnoses": "PrimaryDiagnosis.json",
        "specimens": "Specimen.json",
        "sample_registrations": "SampleRegistration.json",
        "treatments": "Treatment.json",
        "chemotherapies": "Chemotherapy.json",
        "hormone_therapies": "HormoneTherapy.json",
        "radiations": "Radiation.json",
        "immunotherapies": "Immunotherapy.json",
        "surgeries": "Surgery.json",
        "follow_ups": "FollowUp.json",
        "biomarkers": "Biomarker.json",
        "comorbidities": "Comorbidity.json",
    }

    # Load the JSON data from the ordered_name_dict
    for model_name, file_name in name_dict.items():
        with open(
            f"chord_metadata_service/mohpackets/data/no_keys_data/{file_name}", "r"
        ) as f:
            data_without_keys = json.load(f)
        rule = rules.get(model_name)

        data_with_keys = replace_values(data_without_keys, rule)

        # write the transformed data to a json file
        with open(
            f"chord_metadata_service/mohpackets/data/synthetic_data/{file_name}", "w"
        ) as f:
            json.dump(data_with_keys, f, indent=4)
            print(f"Finished processing {file_name}.")


def replace_values(input_data, transformation_rules):
    """
    Replace values in input data using transformation rules.

    Inputs:
        - `input_data`: a list of dictionaries
        - `transformation_rules`:  a list of dictionaries, each defining a rule

    Each rule consists of:
        - `range`: tuple of two integers, specifying range of items to apply the rule to.
        - `targets`: list of dictionaries, each defining a field to be updated.

    Each target consists of:
        - `field_name`: name of field to update.
        - `field_value`: new value of the field.
        - `range`: tuple of two integers, specifying the range of numbers to add to field_value.

    The function updates specified fields by combining field_value (e.g. "DONOR_") with a string
    representation of the target index (e.g. "1"). Target index is calculated by adding
    current item index to target_start, if result is greater than target_end, it's wrapped around.

    Here an example of input data:
    [
        {
            "submitter_donor_id": "DONOR_{REPLACE_ME}",
            "submitter_primary_diagnosis_id": "PRIMARY_DIAGNOSIS_1",
        }
    ]
    and transformation rules:
    [
        {
        "range": [1, 3],
        "targets": [
            {
            "range": [1, 1],
            "field_name": "submitter_donor_id",
            "field_value": "DONOR_"
            }
        ]
        }
    ]
    and the result:
    [
        {
            "submitter_donor_id": "DONOR_1",
            "submitter_primary_diagnosis_id": "PRIMARY_DIAGNOSIS_1",
        }
    ]
    """
    for rule in transformation_rules:
        item_start, item_end = rule["range"]
        target_fields = rule["targets"]

        # loop through each item in the range
        for item_index_offset in range(item_end - item_start + 1):
            item_index = item_start + item_index_offset - 1

            for target_field in target_fields:
                field_name = target_field["field_name"]
                field_value = target_field["field_value"]
                target_start, target_end = target_field["range"]

                # compute the target index
                target_index = target_start + item_index_offset

                # wrap around the target index if it's out of range
                if target_index > target_end:
                    target_index = target_start + (
                        item_index_offset % (target_end - target_start + 1)
                    )

                # replace the value in the input data
                input_data[item_index][field_name] = field_value + str(target_index)
    return input_data


def main():
    print("Select an option:")
    print("1. Set Foreign Keys")
    print("2. Convert to Django fixtures")
    print("3. Exit")

    choice = int(input("Enter your choice [1-3]: "))

    if choice == 1:
        set_foreign_keys()
    elif choice == 2:
        convert_to_fixtures()
    elif choice == 3:
        exit()
    else:
        print("Invalid option. Please try again.")


if __name__ == "__main__":
    main()
